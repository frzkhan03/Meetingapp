{% extends 'base.html' %}

{% block title %}Joining Meeting - PyTalk{% endblock %}

{% block content %}
<div class="container mt-5">
    <div class="row justify-content-center">
        <div class="col-md-5 text-center">
            <div class="card fade-in">
                <div class="card-body py-5">
                    <div class="mb-4">
                        <div class="spinner-border" style="width: 3rem; height: 3rem;" role="status">
                            <span class="visually-hidden">Loading...</span>
                        </div>
                    </div>
                    <h3 class="mb-2">Waiting for Host</h3>
                    <p class="text-secondary mb-4">
                        The host will let you in soon. Please wait...
                    </p>
                    <div id="status-message" class="mb-3"></div>
                    <a href="{% url 'home' %}" class="btn btn-outline-secondary">
                        Cancel
                    </a>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    const roomId = "{{ room_id|escapejs }}";
    const authorId = "{{ author_id|escapejs }}";
    const userId = "{{ user_id|escapejs }}";
    const username = "{{ username|escapejs }}";
    const pendingToken = "{{ pending_token|default:''|escapejs }}";
    const isScheduledMeeting = {% if is_scheduled_meeting %}true{% else %}false{% endif %};
    let responseHandled = false;

    function getCookie(name) {
        let cookieValue = null;
        if (document.cookie && document.cookie !== '') {
            const cookies = document.cookie.split(';');
            for (let i = 0; i < cookies.length; i++) {
                const cookie = cookies[i].trim();
                if (cookie.substring(0, name.length + 1) === (name + '=')) {
                    cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                    break;
                }
            }
        }
        return cookieValue;
    }

    // Send join alert via HTTP (avoids opening a room WebSocket that counts against participant limit)
    async function sendJoinAlert() {
        for (let attempt = 0; attempt < 3; attempt++) {
            try {
                const resp = await fetch('/meeting/room/' + roomId + '/send-alert/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': getCookie('csrftoken')
                    }
                });
                if (resp.ok) {
                    console.log('Join alert sent successfully');
                    return;
                }
                console.warn('send-alert returned ' + resp.status + ', retrying...');
            } catch (err) {
                console.error('Error sending join alert (attempt ' + (attempt + 1) + '):', err);
            }
            await new Promise(r => setTimeout(r, 1000));
        }
    }

    async function handleApprovalResponse(approved) {
        // Prevent duplicate handling
        if (responseHandled) return;
        responseHandled = true;
        clearInterval(alertInterval);
        clearInterval(pollInterval);

        if (approved) {
            document.getElementById('status-message').innerHTML =
                '<div class="alert alert-success">Approved! Joining meeting...</div>';

            // Mark as approved in session before redirecting
            if (pendingToken) {
                for (let attempt = 0; attempt < 3; attempt++) {
                    try {
                        const resp = await fetch('/meeting/room/' + roomId + '/mark-approved/', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'X-CSRFToken': getCookie('csrftoken')
                            }
                        });
                        if (resp.ok) break;
                        console.warn('mark-approved returned ' + resp.status + ', retrying...');
                    } catch (err) {
                        console.error('Error marking approval (attempt ' + (attempt + 1) + '):', err);
                    }
                    await new Promise(r => setTimeout(r, 500));
                }
            }

            setTimeout(() => {
                if (pendingToken && isScheduledMeeting) {
                    window.location.href = '/meeting/join/' + roomId + '/?token=' + pendingToken;
                } else if (pendingToken) {
                    window.location.href = '/meeting/room/' + roomId + '/join/?token=' + pendingToken;
                } else {
                    window.location.href = '/meeting/startmeeting/' + roomId + '/';
                }
            }, 500);
        } else {
            document.getElementById('status-message').innerHTML =
                '<div class="alert alert-danger">The host has denied your request.</div>';
        }
    }

    // ========== WebSocket with heartbeat and reconnection ==========
    const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    const WS_HEARTBEAT_INTERVAL = 25000;
    const WS_HEARTBEAT_TIMEOUT = 10000;
    const WS_MAX_RECONNECT = 15;
    let userSocket = null;
    let pingTimer = null;
    let pongTimer = null;
    let reconnectAttempts = 0;
    let reconnectTimer = null;
    let wsRegistered = false;

    function connectUserSocket() {
        if (responseHandled) return;
        if (reconnectTimer) { clearTimeout(reconnectTimer); reconnectTimer = null; }

        userSocket = new WebSocket(wsProtocol + '//' + window.location.host + '/ws/user/');

        userSocket.onopen = function() {
            console.log('UserSocket connected');
            reconnectAttempts = 0;
            wsRegistered = false;

            // Start heartbeat
            startHeartbeat();

            // Register guest ID if it's a guest user
            if (userId.startsWith('guest_')) {
                userSocket.send(JSON.stringify({
                    type: 'register',
                    user_id: userId
                }));
            } else {
                wsRegistered = true;
            }

            // Send join alert via HTTP after userSocket is ready
            sendJoinAlert();
        };

        userSocket.onmessage = function(e) {
            const data = JSON.parse(e.data);

            // Handle heartbeat pong
            if (data.type === 'pong') {
                if (pongTimer) { clearTimeout(pongTimer); pongTimer = null; }
                return;
            }

            console.log('UserSocket received:', data);

            if (data.type === 'registered') {
                wsRegistered = true;
                console.log('Successfully registered for notifications as:', data.user_id);
            }

            if (data.type === 'alert-response') {
                handleApprovalResponse(data.approved);
            }
        };

        userSocket.onerror = function(e) {
            console.error('WebSocket error:', e);
        };

        userSocket.onclose = function(e) {
            console.log('UserSocket closed:', e.code);
            stopHeartbeat();

            if (!responseHandled && reconnectAttempts < WS_MAX_RECONNECT) {
                const delay = Math.min(1000 * Math.pow(2, reconnectAttempts), 15000);
                const jitter = Math.random() * delay * 0.3;
                console.log('Reconnecting in ' + Math.round(delay + jitter) + 'ms...');
                reconnectTimer = setTimeout(function() {
                    reconnectAttempts++;
                    connectUserSocket();
                }, delay + jitter);
            }
        };
    }

    function startHeartbeat() {
        stopHeartbeat();
        pingTimer = setInterval(function() {
            if (userSocket && userSocket.readyState === WebSocket.OPEN) {
                userSocket.send(JSON.stringify({ type: 'ping' }));
                pongTimer = setTimeout(function() {
                    console.warn('No pong received, closing for reconnect');
                    userSocket.close(4000, 'Heartbeat timeout');
                }, WS_HEARTBEAT_TIMEOUT);
            }
        }, WS_HEARTBEAT_INTERVAL);
    }

    function stopHeartbeat() {
        if (pingTimer) { clearInterval(pingTimer); pingTimer = null; }
        if (pongTimer) { clearTimeout(pongTimer); pongTimer = null; }
    }

    connectUserSocket();

    // ========== HTTP polling fallback ==========
    // Polls the approval status via HTTP in case WebSocket drops and response is missed.
    // This checks if the session has been marked as approved by the moderator.
    async function pollApprovalStatus() {
        if (responseHandled) return;
        try {
            // Try to access the room join URL - if we're approved, it will return 200
            // If not approved, it will redirect to pending (302)
            let checkUrl;
            if (pendingToken && isScheduledMeeting) {
                checkUrl = '/meeting/join/' + roomId + '/?token=' + pendingToken;
            } else if (pendingToken) {
                checkUrl = '/meeting/room/' + roomId + '/join/?token=' + pendingToken;
            } else {
                checkUrl = '/meeting/startmeeting/' + roomId + '/';
            }
            const resp = await fetch(checkUrl, {
                method: 'GET',
                redirect: 'manual',
                headers: { 'X-Requested-With': 'XMLHttpRequest' }
            });
            // If we get 200, the session-based approval or packet exists
            // opaqueredirect means redirect (still pending)
            if (resp.type === 'opaqueredirect' || resp.status === 302) {
                // Still pending
                return;
            }
            if (resp.ok) {
                // We've been approved! Handle it.
                console.log('Polling detected approval');
                handleApprovalResponse(true);
            }
        } catch (err) {
            // Polling errors are non-fatal, just retry next interval
        }
    }

    // Resend alert periodically in case moderator joined after initial alert
    let alertInterval = setInterval(() => {
        if (!responseHandled) {
            sendJoinAlert();
        } else {
            clearInterval(alertInterval);
        }
    }, 15000);

    // Poll for approval every 5 seconds as HTTP fallback
    let pollInterval = setInterval(() => {
        if (!responseHandled) {
            pollApprovalStatus();
        } else {
            clearInterval(pollInterval);
        }
    }, 5000);
</script>
{% endblock %}
