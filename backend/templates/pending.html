{% extends 'base.html' %}

{% block title %}Joining Meeting - PyTalk{% endblock %}

{% block extra_css %}
<style>
    .pending-wrapper {
        min-height: calc(100vh - 80px);
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 2rem 1rem;
        position: relative;
    }

    /* Ambient background glow */
    .pending-wrapper::before {
        content: '';
        position: absolute;
        top: 25%;
        left: 50%;
        transform: translateX(-50%);
        width: 350px;
        height: 350px;
        background: radial-gradient(circle, var(--accent-glow) 0%, transparent 70%);
        border-radius: 50%;
        pointer-events: none;
        z-index: 0;
        opacity: 0.4;
        animation: pending-glow-pulse 4s ease-in-out infinite;
    }

    @keyframes pending-glow-pulse {
        0%, 100% { opacity: 0.4; transform: translateX(-50%) scale(1); }
        50% { opacity: 0.6; transform: translateX(-50%) scale(1.05); }
    }

    .pending-container {
        max-width: 440px;
        width: 100%;
        position: relative;
        z-index: 1;
    }

    .pending-card {
        background: var(--glass-bg);
        backdrop-filter: var(--glass-blur);
        -webkit-backdrop-filter: var(--glass-blur);
        border: 1px solid var(--glass-border);
        border-radius: var(--radius-xl);
        padding: 3rem 2.5rem;
        text-align: center;
        box-shadow: var(--shadow-lg), 0 0 60px rgba(129, 140, 248, 0.08);
        position: relative;
        overflow: hidden;
    }

    /* Subtle top-edge shine */
    .pending-card::before {
        content: '';
        position: absolute;
        top: 0;
        left: 10%;
        right: 10%;
        height: 1px;
        background: linear-gradient(90deg, transparent, rgba(129, 140, 248, 0.4), transparent);
        pointer-events: none;
    }

    /* Custom spinner */
    .pending-spinner-wrap {
        width: 72px;
        height: 72px;
        margin: 0 auto 2rem;
        position: relative;
    }

    .pending-spinner {
        width: 72px;
        height: 72px;
        border-radius: 50%;
        border: 3px solid rgba(255, 255, 255, 0.06);
        border-top-color: var(--accent-primary);
        border-right-color: var(--accent-secondary);
        animation: pending-spin 1s linear infinite;
    }

    .pending-spinner-inner {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 28px;
        height: 28px;
        color: var(--accent-primary);
        opacity: 0.7;
    }

    @keyframes pending-spin {
        to { transform: rotate(360deg); }
    }

    .pending-title {
        font-family: 'Space Grotesk', sans-serif;
        font-size: 1.5rem;
        font-weight: 700;
        color: var(--text-primary);
        margin-bottom: 0.5rem;
        letter-spacing: -0.025em;
    }

    .pending-subtitle {
        color: var(--text-secondary);
        font-size: 0.95rem;
        margin-bottom: 0.5rem;
        line-height: 1.5;
    }

    /* Animated dots */
    .pending-dots {
        display: inline-flex;
        gap: 4px;
        margin-bottom: 2rem;
    }

    .pending-dots span {
        width: 5px;
        height: 5px;
        border-radius: 50%;
        background: var(--accent-primary);
        animation: pending-dot-bounce 1.4s ease-in-out infinite;
    }

    .pending-dots span:nth-child(2) { animation-delay: 0.2s; }
    .pending-dots span:nth-child(3) { animation-delay: 0.4s; }

    @keyframes pending-dot-bounce {
        0%, 80%, 100% { opacity: 0.3; transform: scale(0.8); }
        40% { opacity: 1; transform: scale(1.2); }
    }

    #status-message {
        margin-bottom: 1.5rem;
    }

    #status-message .alert {
        border-radius: var(--radius-md);
        font-size: 0.9rem;
        border: none;
    }

    #status-message .alert-success {
        background: rgba(34, 197, 94, 0.12);
        color: var(--success);
        border: 1px solid rgba(34, 197, 94, 0.2);
    }

    #status-message .alert-danger {
        background: rgba(239, 68, 68, 0.12);
        color: var(--danger);
        border: 1px solid rgba(239, 68, 68, 0.2);
    }

    .pending-cancel-btn {
        display: inline-flex;
        align-items: center;
        gap: 0.5rem;
        padding: 0.625rem 1.5rem;
        font-size: 0.875rem;
        font-weight: 500;
        font-family: 'DM Sans', sans-serif;
        color: var(--text-secondary);
        background: rgba(255, 255, 255, 0.04);
        border: 1px solid var(--glass-border);
        border-radius: var(--radius-md);
        text-decoration: none;
        transition: all 0.2s ease;
        cursor: pointer;
    }

    .pending-cancel-btn:hover {
        color: var(--text-primary);
        background: rgba(255, 255, 255, 0.08);
        border-color: var(--border-light);
    }

    @media (max-width: 576px) {
        .pending-card {
            padding: 2rem 1.5rem;
            border-radius: var(--radius-lg);
        }

        .pending-wrapper::before {
            width: 250px;
            height: 250px;
        }
    }
</style>
{% endblock %}

{% block content %}
<div class="pending-wrapper">
    <div class="pending-container">
        <div class="pending-card">
            <div class="pending-spinner-wrap">
                <div class="pending-spinner" role="status">
                    <span class="visually-hidden">Loading...</span>
                </div>
                <svg class="pending-spinner-inner" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"/>
                </svg>
            </div>

            <h3 class="pending-title">Waiting for Host</h3>
            <p class="pending-subtitle">
                The host will let you in soon
            </p>
            <div class="pending-dots">
                <span></span>
                <span></span>
                <span></span>
            </div>
            <div id="status-message"></div>
            <a href="{% url 'home' %}" class="pending-cancel-btn">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <line x1="18" y1="6" x2="6" y2="18"/>
                    <line x1="6" y1="6" x2="18" y2="18"/>
                </svg>
                Cancel
            </a>
        </div>
    </div>
</div>

<script>
    const roomId = "{{ room_id|escapejs }}";
    const authorId = "{{ author_id|escapejs }}";
    const userId = "{{ user_id|escapejs }}";
    const username = "{{ username|escapejs }}";
    const pendingToken = "{{ pending_token|default:''|escapejs }}";
    const isScheduledMeeting = {% if is_scheduled_meeting %}true{% else %}false{% endif %};
    let responseHandled = false;

    function getCookie(name) {
        let cookieValue = null;
        if (document.cookie && document.cookie !== '') {
            const cookies = document.cookie.split(';');
            for (let i = 0; i < cookies.length; i++) {
                const cookie = cookies[i].trim();
                if (cookie.substring(0, name.length + 1) === (name + '=')) {
                    cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                    break;
                }
            }
        }
        return cookieValue;
    }

    // Send join alert via HTTP (avoids opening a room WebSocket that counts against participant limit)
    async function sendJoinAlert() {
        for (let attempt = 0; attempt < 3; attempt++) {
            try {
                const resp = await fetch('/meeting/room/' + roomId + '/send-alert/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': getCookie('csrftoken')
                    }
                });
                if (resp.ok) {
                    console.log('Join alert sent successfully');
                    return;
                }
                console.warn('send-alert returned ' + resp.status + ', retrying...');
            } catch (err) {
                console.error('Error sending join alert (attempt ' + (attempt + 1) + '):', err);
            }
            await new Promise(r => setTimeout(r, 1000));
        }
    }

    async function handleApprovalResponse(approved) {
        // Prevent duplicate handling
        if (responseHandled) return;
        responseHandled = true;
        clearInterval(alertInterval);
        clearInterval(pollInterval);

        if (approved) {
            document.getElementById('status-message').innerHTML =
                '<div class="alert alert-success">Approved! Joining meeting...</div>';

            // Mark as approved in session before redirecting
            if (pendingToken) {
                for (let attempt = 0; attempt < 3; attempt++) {
                    try {
                        const resp = await fetch('/meeting/room/' + roomId + '/mark-approved/', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'X-CSRFToken': getCookie('csrftoken')
                            }
                        });
                        if (resp.ok) break;
                        console.warn('mark-approved returned ' + resp.status + ', retrying...');
                    } catch (err) {
                        console.error('Error marking approval (attempt ' + (attempt + 1) + '):', err);
                    }
                    await new Promise(r => setTimeout(r, 500));
                }
            }

            setTimeout(() => {
                if (pendingToken && isScheduledMeeting) {
                    window.location.href = '/meeting/join/' + roomId + '/?token=' + pendingToken;
                } else if (pendingToken) {
                    window.location.href = '/meeting/room/' + roomId + '/join/?token=' + pendingToken;
                } else {
                    window.location.href = '/meeting/startmeeting/' + roomId + '/';
                }
            }, 500);
        } else {
            document.getElementById('status-message').innerHTML =
                '<div class="alert alert-danger">The host has denied your request.</div>';
        }
    }

    // ========== WebSocket with heartbeat and reconnection ==========
    const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    const WS_HEARTBEAT_INTERVAL = 25000;
    const WS_HEARTBEAT_TIMEOUT = 10000;
    const WS_MAX_RECONNECT = 15;
    let userSocket = null;
    let pingTimer = null;
    let pongTimer = null;
    let reconnectAttempts = 0;
    let reconnectTimer = null;
    let wsRegistered = false;

    function connectUserSocket() {
        if (responseHandled) return;
        if (reconnectTimer) { clearTimeout(reconnectTimer); reconnectTimer = null; }

        userSocket = new WebSocket(wsProtocol + '//' + window.location.host + '/ws/user/');

        userSocket.onopen = function() {
            console.log('UserSocket connected');
            reconnectAttempts = 0;
            wsRegistered = false;

            // Start heartbeat
            startHeartbeat();

            // Register guest ID if it's a guest user
            if (userId.startsWith('guest_')) {
                userSocket.send(JSON.stringify({
                    type: 'register',
                    user_id: userId
                }));
            } else {
                wsRegistered = true;
            }

            // Send join alert via HTTP after userSocket is ready
            sendJoinAlert();
        };

        userSocket.onmessage = function(e) {
            const data = JSON.parse(e.data);

            // Handle heartbeat pong
            if (data.type === 'pong') {
                if (pongTimer) { clearTimeout(pongTimer); pongTimer = null; }
                return;
            }

            console.log('UserSocket received:', data);

            if (data.type === 'registered') {
                wsRegistered = true;
                console.log('Successfully registered for notifications as:', data.user_id);
            }

            if (data.type === 'alert-response') {
                handleApprovalResponse(data.approved);
            }
        };

        userSocket.onerror = function(e) {
            console.error('WebSocket error:', e);
        };

        userSocket.onclose = function(e) {
            console.log('UserSocket closed:', e.code);
            stopHeartbeat();

            if (!responseHandled && reconnectAttempts < WS_MAX_RECONNECT) {
                const delay = Math.min(1000 * Math.pow(2, reconnectAttempts), 15000);
                const jitter = Math.random() * delay * 0.3;
                console.log('Reconnecting in ' + Math.round(delay + jitter) + 'ms...');
                reconnectTimer = setTimeout(function() {
                    reconnectAttempts++;
                    connectUserSocket();
                }, delay + jitter);
            }
        };
    }

    function startHeartbeat() {
        stopHeartbeat();
        pingTimer = setInterval(function() {
            if (userSocket && userSocket.readyState === WebSocket.OPEN) {
                userSocket.send(JSON.stringify({ type: 'ping' }));
                pongTimer = setTimeout(function() {
                    console.warn('No pong received, closing for reconnect');
                    userSocket.close(4000, 'Heartbeat timeout');
                }, WS_HEARTBEAT_TIMEOUT);
            }
        }, WS_HEARTBEAT_INTERVAL);
    }

    function stopHeartbeat() {
        if (pingTimer) { clearInterval(pingTimer); pingTimer = null; }
        if (pongTimer) { clearTimeout(pongTimer); pongTimer = null; }
    }

    connectUserSocket();

    // ========== HTTP polling fallback ==========
    // Polls the approval status via HTTP in case WebSocket drops and response is missed.
    // This checks if the session has been marked as approved by the moderator.
    async function pollApprovalStatus() {
        if (responseHandled) return;
        try {
            // Try to access the room join URL - if we're approved, it will return 200
            // If not approved, it will redirect to pending (302)
            let checkUrl;
            if (pendingToken && isScheduledMeeting) {
                checkUrl = '/meeting/join/' + roomId + '/?token=' + pendingToken;
            } else if (pendingToken) {
                checkUrl = '/meeting/room/' + roomId + '/join/?token=' + pendingToken;
            } else {
                checkUrl = '/meeting/startmeeting/' + roomId + '/';
            }
            const resp = await fetch(checkUrl, {
                method: 'GET',
                redirect: 'manual',
                headers: { 'X-Requested-With': 'XMLHttpRequest' }
            });
            // If we get 200, the session-based approval or packet exists
            // opaqueredirect means redirect (still pending)
            if (resp.type === 'opaqueredirect' || resp.status === 302) {
                // Still pending
                return;
            }
            if (resp.ok) {
                // We've been approved! Handle it.
                console.log('Polling detected approval');
                handleApprovalResponse(true);
            }
        } catch (err) {
            // Polling errors are non-fatal, just retry next interval
        }
    }

    // Resend alert periodically in case moderator joined after initial alert
    let alertInterval = setInterval(() => {
        if (!responseHandled) {
            sendJoinAlert();
        } else {
            clearInterval(alertInterval);
        }
    }, 15000);

    // Poll for approval every 5 seconds as HTTP fallback
    let pollInterval = setInterval(() => {
        if (!responseHandled) {
            pollApprovalStatus();
        } else {
            clearInterval(pollInterval);
        }
    }, 5000);
</script>
{% endblock %}
